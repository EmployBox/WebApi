package dataMapping.mappers;

import dataMapping.Mapper;
import dataMapping.exceptions.ConcurrencyException;
import dataMapping.exceptions.DataMapperException;
import dataMapping.utils.ConnectionManager;
import model.DomainObject;
import model.AutoGeneratedIdentity;
import util.ReflectionUtils;
import util.Streamable;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.Arrays;
import java.util.Map;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import static util.ReflectionUtils.*;


public abstract class AbstractMapper<T extends DomainObject<K>, K> implements Mapper<T, K> {

    protected final ConcurrentMap<K, T> identityMap = new ConcurrentHashMap<>();
    protected final String SELECT_QUERY;
    protected final String INSERT_QUERY;
    protected final String UPDATE_QUERY;
    protected final String DELETE_QUERY;

    public AbstractMapper(Class<T> type) {

        Field[] fields = allFieldsFor(type).filter(f ->
                f.getType().isPrimitive() ||
                f.getType().isAssignableFrom(String.class) ||
                f.getType().isAssignableFrom(Date.class))
                .toArray(Field[]::new);

        this.SELECT_QUERY = Arrays.stream(fields)
                .map(Field::getName)
                .collect(Collectors.joining(", ", "select ", " from ["+type.getSimpleName()+"]"));

        this.INSERT_QUERY = Arrays.stream(fields)
                .map(Field::getName)
                .collect(Collectors.joining(", ", "insert into [" + type.getSimpleName()+ "] (",
                        ") values ("+ Arrays.stream(fields).map(f -> "?").collect(Collectors.joining(","))+")"));
        this.UPDATE_QUERY = "";
        this.DELETE_QUERY = "";
    }

    public Map<K, T> getIdentityMap() {
        return identityMap;
    }

    /**
     * Converts the current row from result set into an object
     * @param rs
     * @return DomainObject
     * @throws DataMapperException
     */
    abstract T mapper(ResultSet rs) throws DataMapperException;

    /**
     * Inserts the objects read into the LoadedMap
     * @param rs - ResultSet with the result of the DB
     */
    Stream<T> stream(ResultSet rs, Function<ResultSet, T> func) throws DataMapperException{
        return StreamSupport.stream(new Spliterators.AbstractSpliterator<T>(
                Long.MAX_VALUE, Spliterator.ORDERED) {
            @Override
            public boolean tryAdvance(Consumer<? super T> action) {
                try {
                    if(!rs.next())return false;
                    action.accept(func.apply(rs));
                    return true;
                } catch (SQLException e) {
                    throw new DataMapperException(e);
                }
            }
        }, false).onClose(() -> { try { rs.close(); } catch (SQLException e) { throw new DataMapperException(e.getMessage(), e); } });
    }

    private void handleSQLStatement(String query, boolean isProcedure, Consumer<Statement> handleStatement){
        Connection connection = ConnectionManager.getConnectionManagerOfDefaultDB().getConnection();
        try(Statement statement = isProcedure ? connection.prepareCall(query) : connection.prepareStatement(query)) {
            handleStatement.accept(statement);
            connection.close();
        } catch (SQLException e) {
            throw new DataMapperException(e);
        }
            try{ connection.close(); } catch(SQLException e) {}
        }
    }

    /**
     * Gets the object from IdentityMap or queries the DB for it
     * @param query
     * @param key
     * @param prepareStatement
     * @return
     */
    protected Stream<T> executeQuery(String query, K key, Consumer<PreparedStatement> prepareStatement){
        if(identityMap.containsKey(key))
            return Stream.of(identityMap.get(key));

        Object[] result = new Object[1];
        handleSQLStatement(
                query,
                false,
                statement -> {
                    prepareStatement.accept((PreparedStatement) statement);
                    try {
                        result[0] = stream(((PreparedStatement) statement).executeQuery(), this::mapper);
                    } catch (SQLException e) {
                        throw new DataMapperException(e);
                    }
                }
        );
        return (Stream<T>) result[0];
    }

    /**
     * Executes a sql update and saves the obj in the IdentityMap if successful else throws ConcurrencyException
     * @param query
     * @param obj
     * @param prepareStatement
     */
    protected void executeSQLUpdate(String query, T obj, boolean isDeleteCommand, Consumer<PreparedStatement> prepareStatement){
        handleSQLStatement(query,
                false,
                statement -> {
                    prepareStatement.accept((PreparedStatement) statement);
                    try{
                        int rowCount = ((PreparedStatement) statement).executeUpdate();
                        if (rowCount == 0) throw new ConcurrencyException("Concurrency problem found");

                        if (obj instanceof AutoGeneratedIdentity && ((AutoGeneratedIdentity) obj).getIdentityKey() == AutoGeneratedIdentity.getDefaultKey()) {
                            try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
                                if (generatedKeys.next()) ((AutoGeneratedIdentity) obj).setIdentityKey(generatedKeys.getLong(1));

                                else throw new DataMapperException("Creating user failed, no ID obtained.");
                            }
                        }

                        if (isDeleteCommand) identityMap.remove(obj.getIdentityKey());
                        else if(!tryReplace(obj, 5000)) throw new ConcurrencyException("Concurrency problem found, could not update IdentityMap");
                    } catch (SQLException e) {
                        throw new DataMapperException(e.getMessage(), e);
                    }
                }
        );
    }

    protected void executeSQLProcedure(String call, Consumer<CallableStatement> handleStatement){
        handleSQLStatement(
                call,
                true,
                statement -> handleStatement.accept((CallableStatement) statement)
        );
    }

    //TODO Does it work with Inserts?
    private boolean tryReplace(T obj, long timeout){
        long target = System.currentTimeMillis() +  timeout;
        long remaining = target - System.currentTimeMillis();

        while(remaining >= target){
            T observedObj = identityMap.get(obj.getIdentityKey());
            if(observedObj.getVersion() + 1 == obj.getVersion()) {
                if(identityMap.replace(obj.getIdentityKey(), observedObj, obj))
                    return true;
            }

            remaining = target - System.currentTimeMillis();
        }
        return false;
    }
}
